(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{449:function(t,a,e){"use strict";e.r(a);var s=e(44),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"api-reference"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api-reference"}},[t._v("#")]),t._v(" API Reference")]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#ajv-constructor-and-methods"}},[t._v("Ajv constructor and methods")]),e("ul",[e("li",[e("a",{attrs:{href:"#new-ajv-options-object"}},[t._v("new Ajv(options: object)")])]),e("li",[e("a",{attrs:{href:"#ajv-compile-schema-object-data-any-boolean-promise-any"}},[t._v("ajv.compile(schema: object): (data: any) => boolean | Promise < any >")])]),e("li",[e("a",{attrs:{href:"#ajv-compileserializer-schema-object-data-any-string"}},[t._v("ajv.compileSerializer(schema: object): (data: any) => string "),e("Badge",{attrs:{text:"NEW"}})],1)]),e("li",[e("a",{attrs:{href:"#ajv-compileparser-schema-object-json-string-any"}},[t._v("ajv.compileParser(schema: object): (json: string) => any "),e("Badge",{attrs:{text:"NEW"}})],1)]),e("li",[e("a",{attrs:{href:"#ajv-compileasync-schema-object-meta-boolean-promise-function"}},[t._v("ajv.compileAsync(schema: object, meta?: boolean): Promise < Function >")])]),e("li",[e("a",{attrs:{href:"#ajv-validate-schemaorref-object-string-data-any-boolean"}},[t._v("ajv.validate(schemaOrRef: object | string, data: any): boolean")])]),e("li",[e("a",{attrs:{href:"#ajv-addschema-schema-object-object-key-string-ajv"}},[t._v("ajv.addSchema(schema: object | object[], key?: string): Ajv")])]),e("li",[e("a",{attrs:{href:"#ajv-addmetaschema-schema-object-object-key-string-ajv"}},[t._v("ajv.addMetaSchema(schema: object | object[], key?: string): Ajv")])]),e("li",[e("a",{attrs:{href:"#ajv-validateschema-schema-object-boolean"}},[t._v("ajv.validateSchema(schema: object): boolean")])]),e("li",[e("a",{attrs:{href:"#ajv-getschema-key-string-undefined-data-any-boolean-promise-any"}},[t._v("ajv.getSchema(key: string): undefined | ((data: any) => boolean | Promise < any >)")])]),e("li",[e("a",{attrs:{href:"#ajv-removeschema-schemaorref-object-string-regexp-ajv"}},[t._v("ajv.removeSchema(schemaOrRef: object | string | RegExp): Ajv")])]),e("li",[e("a",{attrs:{href:"#ajv-addformat-name-string-format-format-ajv"}},[t._v("ajv.addFormat(name: string, format: Format): Ajv")])]),e("li",[e("a",{attrs:{href:"#ajv-addkeyword-definition-object-ajv"}},[t._v("ajv.addKeyword(definition: object): Ajv")])]),e("li",[e("a",{attrs:{href:"#ajv-getkeyword-keyword-string-object-boolean"}},[t._v("ajv.getKeyword(keyword: string): object | boolean")])]),e("li",[e("a",{attrs:{href:"#ajv-removekeyword-keyword-string-ajv"}},[t._v("ajv.removeKeyword(keyword: string): Ajv")])]),e("li",[e("a",{attrs:{href:"#ajv-errorstext-errors-object-options-object-string"}},[t._v("ajv.errorsText(errors?: object[], options?: object): string")])])])]),e("li",[e("a",{attrs:{href:"#validation-errors"}},[t._v("Validation errors")]),e("ul",[e("li",[e("a",{attrs:{href:"#error-objects"}},[t._v("Error objects")])]),e("li",[e("a",{attrs:{href:"#error-parameters"}},[t._v("Error parameters")])]),e("li",[e("a",{attrs:{href:"#errors-i18n"}},[t._v("Errors i18n")])]),e("li",[e("a",{attrs:{href:"#error-logging"}},[t._v("Error logging")])])])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"ajv-constructor-and-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-constructor-and-methods"}},[t._v("#")]),t._v(" Ajv constructor and methods")]),t._v(" "),e("h3",{attrs:{id:"new-ajv-options-object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-ajv-options-object"}},[t._v("#")]),t._v(" new Ajv(options: object)")]),t._v(" "),e("p",[t._v("Create Ajv instance:")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ajv "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ajv")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("See "),e("a",{attrs:{href:"./options"}},[t._v("Options")])]),t._v(" "),e("h3",{attrs:{id:"ajv-compile-schema-object-data-any-boolean-promise-any"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-compile-schema-object-data-any-boolean-promise-any"}},[t._v("#")]),t._v(" ajv.compile(schema: object): (data: any) => boolean | Promise < any >")]),t._v(" "),e("p",[t._v("Generate validating function and cache the compiled schema for future use.")]),t._v(" "),e("p",[t._v("Validating function returns a boolean value (or promise for async schemas that must have "),e("code",[t._v("$async: true")]),t._v(" property - see "),e("RouterLink",{attrs:{to:"/guide/async-validation.html"}},[t._v("Asynchronous validation")]),t._v("). This function has properties "),e("code",[t._v("errors")]),t._v(" and "),e("code",[t._v("schema")]),t._v(". Errors encountered during the last validation are assigned to "),e("code",[t._v("errors")]),t._v(" property (it is assigned "),e("code",[t._v("null")]),t._v(" if there was no errors). "),e("code",[t._v("schema")]),t._v(" property contains the reference to the original schema.")],1),t._v(" "),e("p",[t._v("The schema passed to this method will be validated against meta-schema unless "),e("code",[t._v("validateSchema")]),t._v(" option is false. If schema is invalid, an error will be thrown. See "),e("a",{attrs:{href:"#options"}},[t._v("options")]),t._v(".")]),t._v(" "),e("p",[t._v("In typescript returned validation function can be a type guard if you pass type parameter:")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" FooSchema"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" JSONSchemaType"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"object"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  properties"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"number"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  required"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  additionalProperties"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" validate "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ajv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token generic-function"}},[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),e("span",{pre:!0,attrs:{class:"token generic class-name"}},[e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FooSchema"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// type of validate extends `(data: any) => data is Foo`")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" data"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("validate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// data is Foo here")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("validate"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("errors"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("See more advanced example in "),e("a",{attrs:{href:"../spec/types/json-schema.spec.ts"}},[t._v("the test")]),t._v(".")]),t._v(" "),e("p",[e("a",{attrs:{name:"jtd-serialize"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-compileserializer-schema-object-data-any-string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-compileserializer-schema-object-data-any-string"}},[t._v("#")]),t._v(" ajv.compileSerializer(schema: object): (data: any) => string "),e("Badge",{attrs:{text:"NEW"}})],1),t._v(" "),e("p",[t._v("Generate serializing function based on the "),e("RouterLink",{attrs:{to:"/json-type-definition.html"}},[t._v("JTD schema")]),t._v(" (caches the schema) - only in JTD instance of Ajv (see example below).")],1),t._v(" "),e("p",[t._v("Serializers compiled from JTD schemas can be more than 10 times faster than using "),e("code",[t._v("JSON.stringify")]),t._v(", because they do not traverse all the data, only the properties that are defined in the schema.")]),t._v(" "),e("p",[t._v("Properties not defined in the schema will not be included in serialized JSON, unless the schema has "),e("code",[t._v("additionalProperties: true")]),t._v(" flag. It can also be beneficial from the application security point of view, as it prevents leaking accidentally/temporarily added additional properties to the API responses.")]),t._v(" "),e("p",[t._v("If you use JTD with typescript, the type for the schema can be derived from the data type, and generated serializer would only accept correct data type in this case:")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" Ajv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("JTDSchemaType"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ajv/dist/jtd"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ajv "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ajv")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyData")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v("\n  bar"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" mySchema"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" JTDSchemaType"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("MyData"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  properties"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    foo"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"int32"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// any JTD number type would be accepted here")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  optionalProperties"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    bar"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" serializeMyData "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ajv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("compileSerializer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mySchema"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// serializeMyData has type (x: MyData) => string")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it prevents you from accidentally passing the wrong type")]),t._v("\n")])])]),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("Compiled serializers do NOT validate data!")]),t._v(" "),e("p",[t._v("It is assumed that the data is valid according to the schema.")])]),t._v(" "),e("p",[e("a",{attrs:{name:"jtd-parse"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-compileparser-schema-object-json-string-any"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-compileparser-schema-object-json-string-any"}},[t._v("#")]),t._v(" ajv.compileParser(schema: object): (json: string) => any "),e("Badge",{attrs:{text:"NEW"}})],1),t._v(" "),e("p",[t._v("Generate parsing function based on the "),e("RouterLink",{attrs:{to:"/json-type-definition.html"}},[t._v("JTD schema")]),t._v(" (caches the schema) - only in JTD instance of Ajv (see example below).")],1),t._v(" "),e("p",[t._v("Parsers compiled from JTD schemas have comparable performance to "),e("code",[t._v("JSON.parse")]),e("sup",[t._v("*")]),t._v(" in case JSON string is valid according to the schema (and they do not just parse JSON - they ensure that parsed JSON is valid according to the schema as they parse), but they can be many times faster in case the string is invalid - for example, if schema expects an object, and JSON string is array the parser would fail on the first character.")]),t._v(" "),e("p",[t._v("Parsing will fail if there are properties not defined in the schema, unless the schema has "),e("code",[t._v("additionalProperties: true")]),t._v(" flag.")]),t._v(" "),e("p",[t._v("If you use JTD with typescript, the type for the schema can be derived from the data type, and generated parser will return correct data type (see definitions example in the "),e("a",{attrs:{href:"#jtd-serialize"}},[t._v("serialize")]),t._v(" section):")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" parseMyData "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ajv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("compileParser")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mySchema"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// parseMyData has type (s: string) => MyData | undefined")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it returns correct data type in case parsing is successful and undefined if not")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" validData "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseMyData")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{\"foo\":1}'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// {foo: 1} - success")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" invalidData "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseMyData")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{\"x\":1}'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined - failure")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parseMyData"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("position"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 4")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("parseMyData"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("message"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// property x not allowed")]),t._v("\n")])])]),e("p",[e("sup",[t._v("*")]),t._v(" As long as empty schema "),e("code",[t._v("{}")]),t._v(" is not used - there is a possibility to improve performance in this case. Also, the performance of parsing "),e("code",[t._v("discriminator")]),t._v(" schemas depends on the position of discriminator tag in the schema - the best parsing performance will be achieved if the tag is the first property - this is how compiled JTD serializers generate JSON in case of discriminator schemas.")]),t._v(" "),e("p",[e("a",{attrs:{name:"api-compileAsync"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-compileasync-schema-object-meta-boolean-promise-function"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-compileasync-schema-object-meta-boolean-promise-function"}},[t._v("#")]),t._v(" ajv.compileAsync(schema: object, meta?: boolean): Promise < Function >")]),t._v(" "),e("p",[t._v("Asynchronous version of "),e("code",[t._v("compile")]),t._v(" method that loads missing remote schemas using asynchronous function in "),e("code",[t._v("options.loadSchema")]),t._v(". This function returns a Promise that resolves to a validation function. An optional callback passed to "),e("code",[t._v("compileAsync")]),t._v(" will be called with 2 parameters: error (or null) and validating function. The returned promise will reject (and the callback will be called with an error) when:")]),t._v(" "),e("ul",[e("li",[t._v("missing schema can't be loaded ("),e("code",[t._v("loadSchema")]),t._v(" returns a Promise that rejects).")]),t._v(" "),e("li",[t._v("a schema containing a missing reference is loaded, but the reference cannot be resolved.")]),t._v(" "),e("li",[t._v("schema (or some loaded/referenced schema) is invalid.")])]),t._v(" "),e("p",[t._v("The function compiles schema and loads the first missing schema (or meta-schema) until all missing schemas are loaded.")]),t._v(" "),e("p",[t._v("You can asynchronously compile meta-schema by passing "),e("code",[t._v("true")]),t._v(" as the second parameter.")]),t._v(" "),e("p",[t._v("Similarly to "),e("code",[t._v("compile")]),t._v(", it can return type guard in typescript.")]),t._v(" "),e("p",[t._v("See example in "),e("RouterLink",{attrs:{to:"/guide/managing-schemas.html#asynchronous-schema-loading"}},[t._v("Asynchronous schema loading")]),t._v(".")],1),t._v(" "),e("h3",{attrs:{id:"ajv-validate-schemaorref-object-string-data-any-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-validate-schemaorref-object-string-data-any-boolean"}},[t._v("#")]),t._v(" ajv.validate(schemaOrRef: object | string, data: any): boolean")]),t._v(" "),e("p",[t._v("Validate data using passed schema (it will be compiled and cached).")]),t._v(" "),e("p",[t._v("Instead of the schema you can use the key that was previously passed to "),e("code",[t._v("addSchema")]),t._v(", the schema id if it was present in the schema or any previously resolved reference.")]),t._v(" "),e("p",[t._v("Validation errors will be available in the "),e("code",[t._v("errors")]),t._v(" property of Ajv instance ("),e("code",[t._v("null")]),t._v(" if there were no errors).")]),t._v(" "),e("p",[t._v("In typescript this method can act as a type guard (similarly to function returned by "),e("code",[t._v("compile")]),t._v(" method - see example there).")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("Save errors property")]),t._v(" "),e("p",[t._v("Every time this method is called the errors are overwritten so you need to copy them to another variable if you want to use them later.")])]),t._v(" "),e("p",[t._v("If the schema is asynchronous (has "),e("code",[t._v("$async")]),t._v(" keyword on the top level) this method returns a Promise. See "),e("RouterLink",{attrs:{to:"/guide/async-validation.html"}},[t._v("Asynchronous validation")]),t._v(".")],1),t._v(" "),e("p",[e("a",{attrs:{name:"add-schema"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-addschema-schema-object-object-key-string-ajv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-addschema-schema-object-object-key-string-ajv"}},[t._v("#")]),t._v(" ajv.addSchema(schema: object | object[], key?: string): Ajv")]),t._v(" "),e("p",[t._v("Add schema(s) to validator instance. This method does not compile schemas (but it still validates them). Because of that dependencies can be added in any order and circular dependencies are supported. It also prevents unnecessary compilation of schemas that are containers for other schemas but not used as a whole.")]),t._v(" "),e("p",[t._v("Array of schemas can be passed (schemas should have ids), the second parameter will be ignored.")]),t._v(" "),e("p",[t._v("Key can be passed that can be used to reference the schema and will be used as the schema id if there is no id inside the schema. If the key is not passed, the schema id will be used as the key.")]),t._v(" "),e("p",[t._v("Once the schema is added, it (and all the references inside it) can be referenced in other schemas and used to validate data.")]),t._v(" "),e("p",[t._v("Although "),e("code",[t._v("addSchema")]),t._v(" does not compile schemas, explicit compilation is not required - the schema will be compiled when it is used first time.")]),t._v(" "),e("p",[t._v("By default the schema is validated against meta-schema before it is added, and if the schema does not pass validation the exception is thrown. This behaviour is controlled by "),e("code",[t._v("validateSchema")]),t._v(" option.")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("Method chaining")]),t._v(" "),e("p",[t._v("Ajv returns its instance for chaining from all methods prefixed "),e("code",[t._v("add*")]),t._v(" and "),e("code",[t._v("remove*")]),t._v(":")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" validate "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ajv")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("addSchema")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("schema"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("addFormat")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" regex"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSchema")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uri"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),e("h3",{attrs:{id:"ajv-addmetaschema-schema-object-object-key-string-ajv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-addmetaschema-schema-object-object-key-string-ajv"}},[t._v("#")]),t._v(" ajv.addMetaSchema(schema: object | object[], key?: string): Ajv")]),t._v(" "),e("p",[t._v("Adds meta schema(s) that can be used to validate other schemas. That function should be used instead of "),e("code",[t._v("addSchema")]),t._v(" because there may be instance options that would compile a meta schema incorrectly (at the moment it is "),e("code",[t._v("removeAdditional")]),t._v(" option).")]),t._v(" "),e("p",[t._v("There is no need to explicitly add draft-07 meta schema (http://json-schema.org/draft-07/schema) - it is added by default, unless option "),e("code",[t._v("meta")]),t._v(" is set to "),e("code",[t._v("false")]),t._v(". You only need to use it if you have a changed meta-schema that you want to use to validate your schemas. See "),e("code",[t._v("validateSchema")]),t._v(".")]),t._v(" "),e("p",[e("a",{attrs:{name:"api-validateschema"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-validateschema-schema-object-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-validateschema-schema-object-boolean"}},[t._v("#")]),t._v(" ajv.validateSchema(schema: object): boolean")]),t._v(" "),e("p",[t._v("Validates schema. This method should be used to validate schemas rather than "),e("code",[t._v("validate")]),t._v(" due to the inconsistency of "),e("code",[t._v("uri")]),t._v(" format in JSON Schema standard.")]),t._v(" "),e("p",[t._v("By default this method is called automatically when the schema is added, so you rarely need to use it directly.")]),t._v(" "),e("p",[t._v("If schema doesn't have "),e("code",[t._v("$schema")]),t._v(" property, it is validated against draft 6 meta-schema (option "),e("code",[t._v("meta")]),t._v(" should not be false).")]),t._v(" "),e("p",[t._v("If schema has "),e("code",[t._v("$schema")]),t._v(" property, then the schema with this id (that should be previously added) is used to validate passed schema.")]),t._v(" "),e("p",[t._v("Errors will be available at "),e("code",[t._v("ajv.errors")]),t._v(".")]),t._v(" "),e("h3",{attrs:{id:"ajv-getschema-key-string-undefined-data-any-boolean-promise-any"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-getschema-key-string-undefined-data-any-boolean-promise-any"}},[t._v("#")]),t._v(" ajv.getSchema(key: string): undefined | ((data: any) => boolean | Promise < any >)")]),t._v(" "),e("p",[t._v("Retrieve compiled schema previously added with "),e("code",[t._v("addSchema")]),t._v(" by the key passed to "),e("code",[t._v("addSchema")]),t._v(" or by its full reference (id). The returned validating function has "),e("code",[t._v("schema")]),t._v(" property with the reference to the original schema.")]),t._v(" "),e("h3",{attrs:{id:"ajv-removeschema-schemaorref-object-string-regexp-ajv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-removeschema-schemaorref-object-string-regexp-ajv"}},[t._v("#")]),t._v(" ajv.removeSchema(schemaOrRef: object | string | RegExp): Ajv")]),t._v(" "),e("p",[t._v("Remove added/cached schema. Even if schema is referenced by other schemas it can be safely removed as dependent schemas have local references.")]),t._v(" "),e("p",[t._v("Schema can be removed using:")]),t._v(" "),e("ul",[e("li",[t._v("key passed to "),e("code",[t._v("addSchema")])]),t._v(" "),e("li",[t._v("it's full reference (id)")]),t._v(" "),e("li",[t._v("RegExp that should match schema id or key (meta-schemas won't be removed)")]),t._v(" "),e("li",[t._v("actual schema object (that will be optionally serialized) to remove schema from cache")])]),t._v(" "),e("p",[t._v("If no parameter is passed all schemas but meta-schemas will be removed and the cache will be cleared.")]),t._v(" "),e("p",[e("a",{attrs:{name:"api-addformat"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-addformat-name-string-format-format-ajv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-addformat-name-string-format-format-ajv"}},[t._v("#")]),t._v(" ajv.addFormat(name: string, format: Format): Ajv")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Format")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// to ignore this format (and pass validation)")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// will be converted to RegExp")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" RegExp\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Object "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// format definition (see below and in types)")]),t._v("\n")])])]),e("p",[t._v("Add format to validate strings or numbers.")]),t._v(" "),e("p",[t._v("If object is passed it should have properties "),e("code",[t._v("validate")]),t._v(", "),e("code",[t._v("compare")]),t._v(" and "),e("code",[t._v("async")]),t._v(":")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FormatDefinition")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// actual type definition is more precise - see types.ts")]),t._v("\n  validate"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" RegExp "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Promise")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  compare"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data1"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" data2"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an optional function that accepts two strings")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// and compares them according to the format meaning.")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This function is used with keywords `formatMaximum`/`formatMinimum`")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (defined in [ajv-keywords](https://github.com/ajv-validator/ajv-keywords) package).")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// It should return `1` if the first value is bigger than the second value,")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `-1` if it is smaller and `0` if it is equal.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// if `validate` is an asynchronous function")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"number"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "string" is default. If data type is different, the validation will pass.')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("Formats can be also added via "),e("code",[t._v("formats")]),t._v(" option.")]),t._v(" "),e("p",[e("a",{attrs:{name:"api-addkeyword"}})]),t._v(" "),e("h3",{attrs:{id:"ajv-addkeyword-definition-object-ajv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-addkeyword-definition-object-ajv"}},[t._v("#")]),t._v(" ajv.addKeyword(definition: object): Ajv")]),t._v(" "),e("p",[t._v("Add validation keyword to Ajv instance.")]),t._v(" "),e("p",[t._v("Keyword should be different from all standard JSON Schema keywords and different from previously defined keywords. There is no way to redefine keywords or to remove keyword definition from the instance.")]),t._v(" "),e("p",[t._v("Keyword must start with a letter, "),e("code",[t._v("_")]),t._v(" or "),e("code",[t._v("$")]),t._v(", and may continue with letters, numbers, "),e("code",[t._v("_")]),t._v(", "),e("code",[t._v("$")]),t._v(", or "),e("code",[t._v("-")]),t._v(".\nIt is recommended to use an application-specific prefix for keywords to avoid current and future name collisions.")]),t._v(" "),e("p",[t._v("Example Keywords:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v('"xyz-example"')]),t._v(": valid, and uses prefix for the xyz project to avoid name collisions.")]),t._v(" "),e("li",[e("code",[t._v('"example"')]),t._v(": valid, but not recommended as it may collide with future versions of JSON Schema etc.")]),t._v(" "),e("li",[e("code",[t._v('"3-example"')]),t._v(": invalid as numbers are not allowed to be the first character in a keyword")])]),t._v(" "),e("p",[t._v("Keyword definition is an object with the following properties:")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("KeywordDefinition")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// actual type definition is more precise - see types.ts")]),t._v("\n  keyword"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword name")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// JSON data type(s) the keyword applies to. Default - all types.")]),t._v("\n  schemaType"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the required schema JSON type")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("code")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function to generate code, used for all pre-defined keywords")]),t._v("\n  validate"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// validating function")]),t._v("\n  compile"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// compiling function")]),t._v("\n  macro"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// macro function")]),t._v("\n  error"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" object "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// error definition object - see types.ts")]),t._v("\n  schema"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// used with "validate" keyword to not pass schema to function')]),t._v("\n  metaSchema"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" object "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// meta-schema for keyword schema")]),t._v("\n  dependencies"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// properties that must be present in the parent schema -")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it will be checked during schema compilation")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword names to reserve that this keyword implements")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("modifying")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MUST be passed if keyword modifies data")]),t._v("\n  valid"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// to pre-define validation result, validation function result will be ignored -")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this option MUST NOT be used with `macro` keywords.")]),t._v("\n  $data"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// to support [\\$data reference](./guide/combining-schemas.md#data-reference) as the value of keyword.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The reference will be resolved at validation time. If the keyword has meta-schema,")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it would be extended to allow $data and it will be used to validate the resolved value.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Supporting $data reference requires that keyword has `code` or `validate` function")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (the latter can be used in addition to `compile` or `macro`).")]),t._v("\n  $dataError"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" object "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// error definition object for invalid \\$data schema - see types.ts")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// if the validation function is asynchronous")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (whether it is returned from `compile` or passed in `validate` property).")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// It should return a promise that resolves with a value `true` or `false`.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// This option is ignored in case of "macro" and "code" keywords.')]),t._v("\n  errors"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"full"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// whether keyword returns errors.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// If this property is not passed Ajv will determine")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// if the errors were set in case of failed validation.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("code",[t._v("compile")]),t._v(", "),e("code",[t._v("macro")]),t._v(" and "),e("code",[t._v("code")]),t._v(" are mutually exclusive, only one should be used at a time. "),e("code",[t._v("validate")]),t._v(" can be used separately or in addition to "),e("code",[t._v("compile")]),t._v(" or "),e("code",[t._v("macro")]),t._v(" to support "),e("RouterLink",{attrs:{to:"/guide/combining-schemas.html#data-reference"}},[t._v("$data reference")]),t._v(".")],1),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("Keyword is validated only for applicable data types")]),t._v(" "),e("p",[t._v("If the keyword is validating data type that is different from the type(s) in its definition, the validation function will not be called (and expanded macro will not be used), so there is no need to check for data type inside validation function or inside schema returned by macro function (unless you want to enforce a specific type and for some reason do not want to use a separate "),e("code",[t._v("type")]),t._v(" keyword for that). In the same way as standard keywords work, if the keyword does not apply to the data type being validated, the validation of this keyword will succeed.")])]),t._v(" "),e("p",[t._v("See "),e("RouterLink",{attrs:{to:"/keywords.html"}},[t._v("User defined keywords")]),t._v(" for more details.")],1),t._v(" "),e("h3",{attrs:{id:"ajv-getkeyword-keyword-string-object-boolean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-getkeyword-keyword-string-object-boolean"}},[t._v("#")]),t._v(" ajv.getKeyword(keyword: string): object | boolean")]),t._v(" "),e("p",[t._v("Returns keyword definition, "),e("code",[t._v("false")]),t._v(" if the keyword is unknown.")]),t._v(" "),e("h3",{attrs:{id:"ajv-removekeyword-keyword-string-ajv"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-removekeyword-keyword-string-ajv"}},[t._v("#")]),t._v(" ajv.removeKeyword(keyword: string): Ajv")]),t._v(" "),e("p",[t._v("Removes added or pre-defined keyword so you can redefine them.")]),t._v(" "),e("p",[t._v("While this method can be used to extend pre-defined keywords, it can also be used to completely change their meaning - it may lead to unexpected results.")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("Compiled schemas and removed keywords")]),t._v(" "),e("p",[t._v("The schemas compiled before the keyword is removed will continue to work without changes. To recompile schemas use "),e("code",[t._v("removeSchema")]),t._v(" method and compile them again.")])]),t._v(" "),e("h3",{attrs:{id:"ajv-errorstext-errors-object-options-object-string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajv-errorstext-errors-object-options-object-string"}},[t._v("#")]),t._v(" ajv.errorsText(errors?: object[], options?: object): string")]),t._v(" "),e("p",[t._v("Returns the text with all errors in a String.")]),t._v(" "),e("p",[t._v("Options can have properties "),e("code",[t._v("separator")]),t._v(' (string used to separate errors, ", " by default) and '),e("code",[t._v("dataVar")]),t._v(' (the variable name that instancePath is prefixed with, "data" by default).')]),t._v(" "),e("h2",{attrs:{id:"validation-errors"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#validation-errors"}},[t._v("#")]),t._v(" Validation errors")]),t._v(" "),e("p",[t._v("In case of validation failure, Ajv assigns the array of errors to "),e("code",[t._v("errors")]),t._v(" property of validation function (or to "),e("code",[t._v("errors")]),t._v(" property of Ajv instance when "),e("code",[t._v("validate")]),t._v(" or "),e("code",[t._v("validateSchema")]),t._v(" methods were called). In case of "),e("RouterLink",{attrs:{to:"/guide/async-validation.html"}},[t._v("asynchronous validation")]),t._v(", the returned promise is rejected with exception "),e("code",[t._v("Ajv.ValidationError")]),t._v(" that has "),e("code",[t._v("errors")]),t._v(" property.")],1),t._v(" "),e("h3",{attrs:{id:"error-objects"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-objects"}},[t._v("#")]),t._v(" Error objects")]),t._v(" "),e("p",[t._v("Each error reported when validating against JSON Schema (also when validating against JTD schema with option "),e("code",[t._v("ajvErrors")]),t._v(") is an object with the following properties:")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorObject")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  keyword"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// validation keyword.")]),t._v("\n  instancePath"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// JSON Pointer to the location in the data instance (e.g., `"/prop/1/subProp"`).')]),t._v("\n  schemaPath"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// JSON Pointer to the location of the failing keyword in the schema")]),t._v("\n  params"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" object "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// type is defined by keyword value, see below")]),t._v("\n                 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// params property is the object with the additional information about error")]),t._v("\n                 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it can be used to generate error messages")]),t._v("\n                 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (e.g., using [ajv-i18n](https://github.com/ajv-validator/ajv-i18n) package).")]),t._v("\n                 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// See below for parameters set by all keywords.")]),t._v("\n  propertyName"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// set for errors in `propertyNames` keyword schema.")]),t._v("\n                        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `instancePath` still points to the object in this case.")]),t._v("\n  message"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the error message (can be excluded with option `messages: false`).")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Options below are added with `verbose` option:")]),t._v("\n  schema"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the value of the failing keyword in the schema.")]),t._v("\n  parentSchema"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" object "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the schema containing the keyword.")]),t._v("\n  data"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the data validated by the keyword.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("For "),e("RouterLink",{attrs:{to:"/json-type-definition.html"}},[t._v("JTD")]),t._v(" schemas "),e("code",[t._v("instancePath")]),t._v(" and "),e("code",[t._v("schemaPath")]),t._v(" depend on the nature of the failure - the errors are consistent with "),e("a",{attrs:{href:"https://datatracker.ietf.org/doc/rfc8927/",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC8927"),e("OutboundLink")],1),t._v(".")],1),t._v(" "),e("h3",{attrs:{id:"error-parameters"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-parameters"}},[t._v("#")]),t._v(" Error parameters")]),t._v(" "),e("p",[t._v("Properties of "),e("code",[t._v("params")]),t._v(" object in errors depend on the keyword that failed validation.")]),t._v(" "),e("p",[t._v("In typescript, the ErrorObject is a discriminated union that allows to determine the type of error parameters based on the value of keyword:")]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ajv "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ajv")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" validate "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ajv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token generic-function"}},[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("compile")]),e("span",{pre:!0,attrs:{class:"token generic class-name"}},[e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("MyData"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("schema"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("validate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// data is MyData here")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// DefinedError is a type for all pre-defined keywords errors,")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// validate.errors has type ErrorObject[] - to allow user-defined keywords with any error parameters.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Users can extend DefinedError to include the keywords errors they defined.")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" err "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" validate"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("errors "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" DefinedError"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("switch")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("err"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("keyword"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"maximum"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("err"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("limit"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"pattern"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("err"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pattern"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("Also see an example in "),e("a",{attrs:{href:"../spec/types/error-parameters.spec.ts"}},[t._v("this test")])]),t._v(" "),e("ul",[e("li",[e("code",[t._v("maxItems")]),t._v(", "),e("code",[t._v("minItems")]),t._v(", "),e("code",[t._v("maxLength")]),t._v(", "),e("code",[t._v("minLength")]),t._v(", "),e("code",[t._v("maxProperties")]),t._v(", "),e("code",[t._v("minProperties")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("limit"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword value")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("additionalItems")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// when `items` is an array of schemas and `additionalItems` is false:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("limit"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the maximum number of allowed items")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("additionalProperties")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("additionalProperty"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the property not defined in `properties` and `patternProperties` keywords")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("dependencies")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  property"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dependent property,")]),t._v("\n  missingProperty"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// required missing dependency - only the first one is reported")]),t._v("\n  deps"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// required dependencies, comma separated list as a string (TODO change to string[])")]),t._v("\n  depsCount"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the number of required dependencies")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("format")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("format"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword value")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("maximum")]),t._v(", "),e("code",[t._v("minimum")]),t._v(", "),e("code",[t._v("exclusiveMaximum")]),t._v(", "),e("code",[t._v("exclusiveMinimum")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  limit"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword value")]),t._v("\n  comparison"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<="')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('">="')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('">"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// operation to compare the data to the limit,")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// with data on the left and the limit on the right")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("multipleOf")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("multipleOf"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword value")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("pattern")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("pattern"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// keyword value")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("required")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("missingProperty"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// required property that is missing")]),t._v("\n")])])]),e("ul",[e("li",[e("code",[t._v("propertyNames")]),t._v(":")])]),t._v(" "),e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorParams")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("propertyName"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// invalid property name")]),t._v("\n")])])]),e("p",[t._v("User-defined keywords can define other keyword parameters.")]),t._v(" "),e("h3",{attrs:{id:"errors-i18n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#errors-i18n"}},[t._v("#")]),t._v(" Errors i18n")]),t._v(" "),e("p",[t._v("You can use "),e("a",{attrs:{href:"https://github.com/ajv-validator/ajv-i18n",target:"_blank",rel:"noopener noreferrer"}},[t._v("ajv-i18n"),e("OutboundLink")],1),t._v(" package to generate errors in other languages.")]),t._v(" "),e("h3",{attrs:{id:"error-logging"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-logging"}},[t._v("#")]),t._v(" Error logging")]),t._v(" "),e("p",[t._v("A logger instance can be passed via "),e("code",[t._v("logger")]),t._v(" option to Ajv constructor. The use of other logging packages is supported as long as the package or its associated wrapper exposes the required methods. If any of the required methods are missing an exception will be thrown.")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("Required Methods")]),t._v(": "),e("code",[t._v("log")]),t._v(", "),e("code",[t._v("warn")]),t._v(", "),e("code",[t._v("error")])])]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" otherLogger "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OtherLogger")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ajv "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ajv")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  logger"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    log"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("warn")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("warn")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      otherLogger"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("logWarn")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("otherLogger"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("error")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      otherLogger"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("logError")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("otherLogger"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h5",{attrs:{id:"options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#options"}},[t._v("#")]),t._v(" Options")]),t._v(" "),e("p",[t._v("This section is moved to "),e("RouterLink",{attrs:{to:"/options.html"}},[t._v("Initialization options")]),t._v(" page")],1)])}),[],!1,null,null,null);a.default=r.exports}}]);